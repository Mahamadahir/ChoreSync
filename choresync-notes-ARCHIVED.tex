\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage[dvipsnames]{xcolor}
\setlist{nosep}

\title{ChoreSync -- Notebook Design Notes}
\author{}
\date{}

\begin{document}
	\maketitle
	
	\section{Core Idea}
	
	\subsection*{One-sentence description}
	ChoreSync intelligently assigns household chores within a group by taking into account:
	\begin{itemize}
		\item Each member's availability (via external calendar sync).
		\item Each member's task preferences.
		\item Each member's historical workload and behaviour.
	\end{itemize}
	
	\subsection*{Inputs the assignment engine uses}
	\begin{itemize}
		\item \textbf{Availability}
		\begin{itemize}
			\item Sync with external calendars.
			\item Use events that block time to determine when users are free.
		\end{itemize}
		\item \textbf{Preferences}
		\begin{itemize}
			\item Per-task (task template) preferences.
		\end{itemize}
		\item \textbf{History}
		\begin{itemize}
			\item How many hours each user has done recently.
			\item Who tends to get tasks they dislike regularly.
			\item Who keeps swapping away from particular tasks.
			\item Each member's on-time completion streak (number of consecutive days
			they have met all task deadlines).
		\end{itemize}
		\item \textbf{Reassignment}
		\begin{itemize}
			\item When a user leaves the group while still having tasks.
			\item When a swap is accepted.
			\item When reassignment rules fire (e.g.\ after $n$ tasks or $n$ weeks).
		\end{itemize}
	\end{itemize}
	
	\section{Key Flows}
	
	\subsection{How groups are created}
	
	\textbf{Prerequisite:}
	\begin{itemize}
		\item A user (call them User A) is logged in.
	\end{itemize}
	
	\textbf{Flow:}
	\begin{enumerate}
		\item User A clicks \emph{Create group}.
		\item User A inputs group name and (optionally) a description.
		\item System creates a \texttt{Group} object with User A as owner/creator.
	\end{enumerate}
	
	\textbf{Considerations:}
	\begin{itemize}
		\item When a new user later joins the group:
		\begin{itemize}
			\item Handle existing tasks differently based on \texttt{TaskTemplate.importance}:
			\begin{itemize}
				\item For \emph{core} tasks:
				
				% REPLACING NESTED LISTS WITH \paragraph
				\paragraph*{Mandatory Preference Dialog:}
				On join, show a mandatory preferences dialog: ``There are $n$ core tasks in this group. You will have to choose your preferences for each of them.''
				
				\paragraph*{Join Wizard Block:}
				Block completion of the join wizard until the user has set \texttt{TaskPreference} values for all core templates.
				
				\item For \emph{additional} tasks:
				
				% REPLACING NESTED LISTS WITH \paragraph
				\paragraph*{Optional Preference Dialog:}
				After core tasks are done, show a second dialog: ``There are $m$ additional tasks active in this group. Do you want to choose preferences now, or set all to neutral?''
				
				\paragraph*{Neutral Opt-Out:}
				If the user opts out, create neutral \texttt{TaskPreference} rows for all active additional templates and allow them to refine later.
			\end{itemize}
		\end{itemize}
		...
	\end{itemize}
	
	\subsection{How tasks are created (proposal flow)}
	
	\textbf{Prerequisites:}
	\begin{itemize}
		\item A non-empty group exists.
		\item A user within the group (User A) is logged in and is a member of that group.
	\end{itemize}
	
	\textbf{Flow:}
	\begin{enumerate}
		\item User A opens the ``propose task'' screen for a given group and fills in the task details
		(name, description, estimated hours, recurrence choice, next due date, etc.).
		\item The system creates a \texttt{TaskTemplate} object with:
		\begin{itemize}
			\item \texttt{group =} the current group.
			\item \texttt{creator =} User A.
			\item Recurrence fields (\texttt{recurring\_choice}, \texttt{recur\_value}, \texttt{next\_due}).
			\item \texttt{active = True} (the template is a real candidate chore, but not yet scheduled to everyone).
		\end{itemize}
		\item The system creates a \texttt{TaskProposal} object linked to that template:
		\begin{itemize}
			\item \texttt{task\_template =} the template created above.
			\item \texttt{group =} the current group.
			\item \texttt{proposed\_by =} User A.
			\item \texttt{state = 'pending'} plus optional \texttt{voting\_deadline} and \texttt{required\_support\_ratio}.
		\end{itemize}
		\item As members view the proposal and vote, the system creates or updates:
		\begin{itemize}
			\item \texttt{TaskVote} rows (\texttt{proposal}, \texttt{voter}, \texttt{choice}) for each member.
			\item \texttt{TaskPreference} rows (\texttt{task\_template}, \texttt{user}, \texttt{preference}) whenever
			members express a preference for that task during the voting process.
		\end{itemize}
		\item For each group member, the system creates a \texttt{Notification} of type
		\texttt{'task\_proposal'} with:
		\begin{itemize}
			\item \texttt{recipient =} the member.
			\item \texttt{group =} the group.
			\item \texttt{task\_proposal =} the proposal.
			\item \texttt{content} summarising the proposal and inviting them to vote.
		\end{itemize}
		\item Group members receive the notification, open the proposal view, cast their vote
		(\texttt{TaskVote}) and optionally set their \texttt{TaskPreference} for the template.
		\item Once all required members have voted or the \texttt{voting\_deadline} passes, the proposal
		is evaluated:
		\begin{itemize}
			\item If the support threshold is not met, the proposal is marked
			\texttt{state = 'rejected'} or \texttt{'expired'}; the underlying \texttt{TaskTemplate}
			may be kept (inactive / for later) or deleted, depending on policy.
			\item If the support threshold \emph{is} met, the proposal is marked
			\texttt{state = 'approved'} and \texttt{approved\_at} is set.
		\end{itemize}
		\item If the proposal is approved:
		\begin{enumerate}
			\item The system uses the \texttt{TaskTemplate} definition to create one or more
			\texttt{TaskOccurrence} objects for upcoming due dates.
			\item For each occurrence, the assignment engine chooses an \texttt{assigned\_to} user
			based on availability, preferences and fairness/history (see Task Scheduler Design).
			\item The system emits \texttt{Notification} objects of type \texttt{'task\_assigned'}
			for affected users, linking to the relevant \texttt{TaskOccurrence} and \texttt{group}.
		\end{enumerate}
	\end{enumerate}
	
	\subsection{Assignment and reassignment}
	
	\begin{itemize}
		\item When the system creates a \texttt{TaskOccurrence}, it assigns the task to a user based on:
		\begin{itemize}
			\item \textbf{Availability}: events in \texttt{Calendar} / \texttt{Event} where
			\texttt{include\_in\_availability = True} and \texttt{blocks\_availability = True}
			determine who is actually free around the task's \texttt{deadline}.
			\item \textbf{Preferences}: \texttt{TaskPreference} weights for \texttt{task\_template}
			(e.g.\ \texttt{prefer}/\texttt{neutral}/\texttt{avoid}) bias the candidate scoring.
			\item \textbf{History / fairness}: recent \texttt{TaskOccurrence} assignments and completions,
			plus swap behaviour (\texttt{TaskSwap}), are used to avoid overloading the same person
			and to avoid repeatedly assigning disliked tasks to the same member.
		\end{itemize}
		\item If a user leaves the group while they still have outstanding tasks:
		\begin{itemize}
			\item Services (e.g.\ a membership removal handler) locate all open \texttt{TaskOccurrence}
			rows where \texttt{assigned\_to} is that user and the \texttt{template.group} is the
			relevant group.
			\item Those occurrences are either:
			\begin{itemize}
				\item Immediately reassigned using the same assignment engine, or
				\item Marked for reassignment according to the group's \texttt{reassignment\_rule}
				(\texttt{'on\_create'}, \texttt{'after\_n\_tasks'}, or \texttt{'after\_n\_weeks'})
				and \texttt{reassignment\_value}.
			\end{itemize}
		\end{itemize}
		\item When a \texttt{TaskSwap} is accepted, services update the corresponding
		\texttt{TaskOccurrence.assigned\_to} to the \texttt{to\_user} and may log this in the
		member's history so repeated swaps away from a task can influence future assignments.
	\end{itemize}
	
	
	\subsection{Important user flows (list)}
	
	The app should support at least the following end-to-end flows:
	
	\begin{itemize}
		\item Account creation.
		\item User login.
		\item Group creation.
		\item Calendar sync.
		\item OAuth sign-up.
		\item OAuth login.
		\item Task creation / task proposal flow.
		\item Sending messages to the group.
	\end{itemize}
	
	\section{Task Scheduler Design}
	
	This section sketches the first-pass design of the assignment engine that chooses an assignee for each \texttt{TaskOccurrence}.
	
	\subsection*{When the scheduler runs}
	
	The scheduler is invoked in the following situations:
	\begin{itemize}
		\item When a proposal is approved and new \texttt{TaskOccurrence} rows are created.
		\item When group-level reassignment rules trigger:
		\begin{itemize}
			\item \texttt{Group.reassignment\_rule = 'on\_create'}: run on every new occurrence.
			\item \texttt{'after\_n\_tasks'}: after \texttt{reassignment\_value} new occurrences.
			\item \texttt{'after\_n\_weeks'}: periodically based on elapsed time.
		\end{itemize}
		\item When a member leaves the group and has outstanding tasks.
		\item When a swap is accepted and we want to log the swap behaviour into history metrics.
	\end{itemize}
	
	---
	
	\subsection*{Inputs}
	
	For a given \texttt{TaskOccurrence} (and its \texttt{TaskTemplate}), the scheduler considers:
	\begin{itemize}
		\item Eligible group members (e.g.\ active \texttt{GroupMembership} rows).
		\item Each member's availability window around the occurrence deadline (derived from \texttt{Calendar} and \texttt{Event}).
		\item \texttt{TaskPreference} for that template (or default neutral when no row exists).
		\item Historical workload:
		\begin{itemize}
			\item Number of tasks / hours assigned in a recent rolling window.
			\item How often they have completed similar tasks.
		\end{itemize}
		\item Swap behaviour:
		\begin{itemize}
			\item How often the member has swapped away from this template (\texttt{TaskSwap} rows where they were \texttt{from\_user}).
			\item How often the member has voluntarily accepted swaps into this template.
		\end{itemize}
		\item Recurrence history:
		\begin{itemize}
			\item If this is a recurring task, the previous assignee for the last occurrence of the same template.
		\end{itemize}
	\end{itemize}
	
	---
	
	\subsection*{Scoring model (first pass)}
	
	For each eligible member $u$, the scheduler computes a score of the form:
	\[
	\text{score}(u) = S'_{\text{avail}}(u) + S'_{\text{pref}}(u)+ S'_{\text{fair}}(u) + S'_{\text{recur}}(u) + S'_{\text{swap}}(u) + S'_{\text{streak}}(u)
	\]
	
	
	Where the sub-scores $S'_i$ already contain their respective weights. Below are the detailed calculations:
	
	\begin{itemize}
		\item $S'_{\text{avail}}(u)$ (Availability Score)
		\begin{itemize}
			\item \textbf{Weight}: $W_{\text{avail}} = 100$. Final Range: $[-100, 0]$.
			\item \textbf{Calculation}: 
			Calculates the conflict ratio $R_c$ of the user's "busy" events ($T_C$) overlapping the task's required time window ($T_R$).
			\[
			S_{\text{avail}}(u) = -R_c = - \left( \frac{T_C}{T_R} \right)
			\]
			\[
			S'_{\text{avail}}(u) = 100 \times S_{\text{avail}}(u)
			\]
			\item \textbf{Model Fields Used}:
			\begin{itemize}
				\item \texttt{TaskOccurrence.deadline} (to define $T_R$)
				\item \texttt{Calendar.include\_in\_availability} (to find relevant calendars)
				\item \texttt{Event.blocks\_availability} (to find blocking events)
				\item \texttt{Event.start} and \texttt{Event.end} (to calculate $T_C$)
			\end{itemize}
		\end{itemize}
		
		\item $S'_{\text{fair}}(u)$ (Fairness Score)
		\begin{itemize}
			\item \textbf{Weight}: $W_{\text{fair}} = 10$. Final Range: $[-10, +10]$.
			\item \textbf{Calculation}: 
			Calculates the user's workload $H(u)$ (e.g., sum of \texttt{estimated\_hours}) in a rolling window, and compares it to the group's $H_{\text{median}}$. $H_{\text{max\_dev}}$ is a constant cap.
			
			\[
			S_{\text{fair}}(u) = \frac{H_{\text{median}} - H(u)}{H_{\text{max\_dev}}} \quad (\text{clamped to } [-1.0, +1.0])
			\]
			\[
			S'_{\text{fair}}(u) = 10 \times S_{\text{fair}}(u)
			\]
			\item \textbf{Model Fields Used}:
			\begin{itemize}
				\item \texttt{TaskOccurrence.assigned\_to} and \texttt{deadline} (to find $H(u)$ in window)
				\item \texttt{TaskTemplate.estimated\_hours} (to sum $H(u)$)
				\item \texttt{Group.members} (to find all users for $H_{\text{median}}$)
			\end{itemize}
		\end{itemize}
		
		\item $S'_{\text{pref}}(u)$ (Preference Score)
		\begin{itemize}
			\item \textbf{Weight}: $W_{\text{pref}} = 10$. Final Range: $\{-10, 0, +10\}$.
			\item \textbf{Calculation}: 
			A direct lookup of the user's preference for the given template.
			\[
			S_{\text{pref}}(u) = \texttt{TaskPreference.weight()}
			\]
			\[
			S'_{\text{pref}}(u) = 10 \times S_{\text{pref}}(u)
			\]
			\item \textbf{Model Fields Used}:
			\begin{itemize}
				\item \texttt{TaskOccurrence.template} (to find the template)
				\item \texttt{TaskPreference.user}, \texttt{TaskPreference.task\_template}
				\item \texttt{TaskPreference.preference} (via the \texttt{.weight()} helper)
			\end{itemize}
		\end{itemize}
		
		\item $S'_{\text{swap}}(u)$ (Swap Score)
		\begin{itemize}
			\item \textbf{Weight}: $W_{\text{swap}}$ (e.g., 5). Final Range: $[-W_{\text{swap}}, +W_{\text{swap}}]$.
			\item \textbf{Calculation}: 
			Calculates the user's net swap behavior \textbf{for the specific \texttt{TaskTemplate} currently being assigned}. This is based on accepted swaps ($N_{\text{accept}}$) vs. swaps away ($N_{\text{away}}$) *for historical occurrences of this template only*.
			\[
			S_{\text{swap}}(u) = \frac{N_{\text{accept}} - N_{\text{away}}}{N_{\text{assigned}}} \quad (\text{if } N_{\text{assigned}} > 0, \text{else } 0)
			\]
			\[
			S'_{\text{swap}}(u) = W_{\text{swap}} \times S_{\text{swap}}(u)
			\]
			\item \textbf{Model Fields Used}:
			\begin{itemize}
				\item \texttt{TaskOccurrence.template} (to scope the history to *this* template)
				\item \texttt{TaskOccurrence.assigned\_to} (to find $N_{\text{assigned}}$ for *this* template)
				\item \texttt{TaskSwap.from\_user} (for $N_{\text{away}}$, queried via the task's template)
				\item \texttt{TaskSwap.to\_user} and \texttt{TaskSwap.status} (for $N_{\text{accept}}$, queried via the task's template)
			\end{itemize}
		\end{itemize}
		
		\item $S'_{\text{recur}}(u)$ (Recurrence Score)
		\begin{itemize}
			\item \textbf{Weight}: $W_{\text{recur}} = 0$. Final Score: $0$.
			\item \textbf{Calculation}: 
			The input $S_{\text{recur}}(u)$ is $+1$ if the user was the assignee of the immediately preceding occurrence of this template, and $0$ otherwise. The weighted score is $0$, used only for logging.
			\item \textbf{Model Fields Used}:
			\begin{itemize}
				\item \texttt{TaskOccurrence.template}, \texttt{deadline}, and \texttt{assigned\_to} (to find the previous assignee)
			\end{itemize}
		\end{itemize}
		
		\item $S'_{\text{streak}}(u)$ (Streak Score)
		\begin{itemize}
			\item \textbf{Weight}: $W_{\text{streak}}$ (e.g., 2). Final Range: $[0, +W_{\text{streak}}]$.
			\item \textbf{Calculation}: 
			Calculates a normalized score based on the user's current streak $L(u)$ relative to a target streak $L_{\text{target}}$.
			\[
			S_{\text{streak}}(u) = \min \left( 1.0, \frac{L(u)}{L_{\text{target}}} \right)
			\]
			\[
			S'_{\text{streak}}(u) = W_{\text{streak}} \times S_{\text{streak}}(u)
			\]
			\item \textbf{Model Fields Used}:
			\begin{itemize}
				\item \texttt{User.on\_time\_streak\_days} (as $L(u)$)
			\end{itemize}
		\end{itemize}
		
	\end{itemize}
	
	The engine selects the user with the highest score. If all candidates are highly negative (e.g.\ everyone is busy or strongly \texttt{avoid}s the task), the system still chooses the ``least bad'' candidate but can flag this as an ``unhappy assignment'' in logs or UI.
	
	---
	
	\subsubsection*{Detailed Fairness Formula}
	
	The unweighted $\text{Fairness}$ input score $S_{\text{fair}}(u)$ (range $[-1.0, +1.0]$) is calculated as:
	
	\[
	S_{\text{fair}}(u) = \frac{H_{\text{median}} - H(u)}{H_{\text{max\_dev}}} \quad \text{where} \quad \left| H_{\text{median}} - H(u) \right| \leq H_{\text{max\_dev}}
	\]
	If the absolute deviation $\left| H_{\text{median}} - H(u) \right|$ exceeds the defined $H_{\text{max\_dev}}$ cap, the $S_{\text{fair}}(u)$ is clamped to $\pm 1.0$.
	
	\begin{itemize}
		\item $H(u)$ is the user's recent assigned workload (hours/tasks).
		\item $H_{\text{median}}$ is the group's median recent workload.
		\item $H_{\text{max\_dev}}$ is the maximum acceptable deviation from the median before the score caps (e.g., 10 hours).
	\end{itemize}
	
	---
	
	\subsection*{Tie-breaking}
	
	When scores tie, the scheduler breaks ties using the revised order:
	\begin{enumerate}
		\item \textbf{Stronger preference} (e.g.\ \texttt{prefer} over \texttt{neutral}).
		\item Fewer total hours assigned in the recent window.
		\item Lower historical swap-away count for this template.
		\item Stable randomisation (e.g.\ seeded by group and user ID) to avoid biasing toward low-ID users.
	\end{enumerate}
	
	---
	
	\subsection*{Recurring tasks}
	
	For recurring chores:
	\begin{itemize}
		\item The previous assignee is tracked (for $S'_{\text{recur}}$) but receives no score bonus ($W_{\text{recur}}=0$).
		\item If the previous assignee has repeatedly swapped away from this template, this is already captured in their $S'_{\text{swap}}$ score.
		\item The engine ensures that, over time, recurring tasks do not latch permanently onto one person because this would be corrected by the $S'_{\text{fair}}$ score.
	\end{itemize}
	
	---
	
	\subsection*{On-time streak tracking}
	
	For each user, the system maintains:
	
	\begin{itemize}
		\item \texttt{User.on\_time\_streak\_days}: number of consecutive days on which
		the user has met all task deadlines.
		\item \texttt{User.longest\_on\_time\_streak\_days}: longest historical streak.
		\item \texttt{User.last\_streak\_date}: date on which the streak was last updated.
	\end{itemize}
	
	A daily job (or equivalent service) evaluates, for each user, whether any
	tasks due on the previous day were not completed on time. If so, the
	streak resets to zero. If not, the streak is incremented by~1. Days with
	no tasks due do not break the streak but also do not increment it.
	
	\section{Task Preferences Model}
	
	\subsection*{Domain model}
	
	Task preferences are represented by the \texttt{TaskPreference} model:
	\begin{itemize}
		\item \texttt{user} $\rightarrow$ \texttt{User} (on\_delete=\texttt{CASCADE}).
		\item \texttt{task\_template} $\rightarrow$ \texttt{TaskTemplate} (on\_delete=\texttt{CASCADE}).
		\item \texttt{preference} $\in \{\texttt{prefer}, \texttt{neutral}, \texttt{avoid}\}$.
		\item \texttt{reason}: optional free-text explanation.
	\end{itemize}
	
	Each (\texttt{user}, \texttt{task\_template}) pair has at most one row; uniqueness is enforced by \texttt{unique\_together}.
	
	\subsection*{Numeric weighting}
	
	A helper method on the model maps preferences to numeric weights:
	\[
	\texttt{prefer} \mapsto +1,\quad \texttt{neutral} \mapsto 0,\quad \texttt{avoid} \mapsto -1.
	\]
	
	The scheduler uses these weights as $S_{\text{preference}}$ inputs, scaled appropriately. Future versions could introduce a richer scale (e.g.\ $-2$ to $+2$) without changing the external API.
	
	\subsection*{Defaults and lifecycle}
	
	\begin{itemize}
		\item When a \textbf{new user joins a group}, they conceptually start as \texttt{neutral} for all existing templates in that group.
		\begin{itemize}
			\item Implementation detail: the system can either explicitly create \texttt{TaskPreference} rows with \texttt{neutral}, or treat ``missing row'' as neutral in queries.
		\end{itemize}
		\item When a \textbf{new template is approved}, all existing members are again treated as \texttt{neutral} until they express a preference.
		\item Preferences can be updated:
		\begin{itemize}
			\item During the voting flow for a proposal.
			\item On a dedicated ``Preferences'' UI for the group.
			\item As a side-effect of repeated swaps away from a task (optional future behaviour: auto-suggest setting \texttt{avoid}).
		\end{itemize}
	\end{itemize}
	
	\section{Swap Behaviour}
	
	\subsection*{Model}
	
	Swaps are captured by \texttt{TaskSwap}:
	\begin{itemize}
		\item \texttt{task} $\rightarrow$ \texttt{TaskOccurrence} (on\_delete=\texttt{CASCADE}).
		\item \texttt{from\_user}, \texttt{to\_user} $\rightarrow$ \texttt{User} (on\_delete=\texttt{SET\_NULL}).
		\item \texttt{status} $\in \{\texttt{pending}, \texttt{accepted}, \texttt{rejected}, \texttt{cancelled}\}$.
	\end{itemize}
	
	\subsection*{Open-ended swaps}
	
	Swaps are designed to be open-ended:
	\begin{itemize}
		\item At creation time, \texttt{from\_user} is set to the current assignee, and \texttt{to\_user} is left \texttt{null}.
		\item Any eligible group member can accept the swap.
		\item Upon acceptance:
		\begin{itemize}
			\item \texttt{to\_user} is set to the accepting member.
			\item \texttt{TaskOccurrence.assigned\_to} is updated.
			\item \texttt{status} is set to \texttt{'accepted'} and \texttt{decided\_at} is recorded.
		\end{itemize}
	\end{itemize}
	
	\subsection*{Impact on fairness and future assignment}
	
	Swaps feed back into the scheduler via derived metrics, for example:
	\begin{itemize}
		\item \textbf{Swap-away count}: number of times a user has initiated a swap away from a given template.
		\item \textbf{Swap-in count}: number of times a user has voluntarily accepted a swap into a given template.
	\end{itemize}
	
	Possible policies:
	\begin{itemize}
		\item If a member frequently swaps away from a template, reduce $S_{\text{recurrence}}$ and/or add a small negative term in $S_{\text{swap}}$ to avoid assigning that task to them too often.
		\item If a member frequently accepts swaps into a template, give them a small positive bias when they are otherwise fairly treated.
		\item Keep guardrails soft: swaps are voluntary and not blocked, but the engine tries not to ignore strong behavioural signals.
	\end{itemize}
	
	\section{Availability Model}
	
	\subsection*{Calendar sources}
	
	Each user may have multiple \texttt{Calendar} rows:
	\begin{itemize}
		\item Provider is one of \texttt{'internal'}, \texttt{'google'}, \texttt{'microsoft'}.
		\item An ``in-app'' primary calendar is represented by a \texttt{Calendar} with \texttt{provider='internal'} and \texttt{external\_id = null}.
		\item External calendars are linked to \texttt{ExternalCredential} where applicable.
	\end{itemize}
	
	\subsection*{Event normalisation}
	
	All time blocks are normalised into the \texttt{Event} model:
	\begin{itemize}
		\item \texttt{source} indicates \texttt{'external'}, \texttt{'task'} or \texttt{'manual'}.
		\item External provider events are imported as \texttt{source='external'} with \texttt{external\_event\_id} populated.
		\item Task-derived events are created with \texttt{source='task'} and a pointer to \texttt{TaskOccurrence}.
		\item Manually created in-app events use \texttt{source='manual'}.
	\end{itemize}
	
	\subsection*{Computing availability}
	
	Availability is derived from events as follows:
	\begin{itemize}
		\item Only calendars where \texttt{include\_in\_availability = True} are considered.
		\item Within those calendars, only events where \texttt{blocks\_availability = True} are treated as ``busy''.
		\item The engine considers events within a configurable time horizon (e.g.\ \texttt{Calendar.sync\_window\_days} or a separate scheduling window) when deciding if a user can reasonably take on a task.
		\item All-day events (\texttt{is\_all\_day=True}) are treated as blocking the entire day unless explicitly marked non-blocking.
	\end{itemize}
	
	\subsection*{Group views and primary calendars}
	
	\begin{itemize}
		\item Each user has at least one internal calendar that acts as their primary in-app schedule.
		\item Task-derived events can be written to:
		\begin{itemize}
			\item The assignee's internal calendar; and/or
			\item An aggregated group calendar view (governed by \texttt{GroupCalendar} settings).
		\end{itemize}
		\item \texttt{GroupCalendar} controls whether:
		\begin{itemize}
			\item Member calendars are shown in an aggregate view.
			\item Task-derived events are included in that group view.
		\end{itemize}
	\end{itemize}
	
	\section{Notifications and Click-through}
	
	\subsection*{Types}
	
	Notifications are represented by the \texttt{Notification} model with \texttt{type} in:
	\begin{itemize}
		\item \texttt{'task\_assigned'}: a task has been assigned to the recipient.
		\item \texttt{'task\_swap'}: a swap request or response relevant to the recipient.
		\item \texttt{'group\_invite'}: an invitation to join a group.
		\item \texttt{'task\_proposal'}: a new or updated proposal the recipient should vote on.
		\item \texttt{'message'}: a message-related notification (e.g.\ mention or summary).
	\end{itemize}
	
	\subsection*{Deep-linking to source entities}
	
	Notifications link back to domain entities using foreign keys:
	\begin{itemize}
		\item \textbf{Task-related}:
		\begin{itemize}
			\item \texttt{task\_assigned}: typically sets \texttt{group} and \texttt{task\_occurrence}, allowing the frontend to route to a view like \texttt{/groups/<group\_id>/tasks/<occurrence\_id>}.
			\item \texttt{task\_swap}: sets \texttt{group} and \texttt{task\_occurrence}; the UI can open a ``swap details'' modal for that occurrence.
		\end{itemize}
		\item \textbf{Proposals}:
		\begin{itemize}
			\item \texttt{task\_proposal}: sets \texttt{group} and \texttt{task\_proposal}; clicking opens a proposal/voting screen.
		\end{itemize}
		\item \textbf{Messaging}:
		\begin{itemize}
			\item \texttt{message}: sets \texttt{group} and \texttt{message}; the frontend opens the group chat view and, optionally, scrolls to that message.
		\end{itemize}
		\item \textbf{Group invites}:
		\begin{itemize}
			\item \texttt{group\_invite}: sets \texttt{group}; the UI opens a join/accept screen.
		\end{itemize}
	\end{itemize}
	
	Exact URL patterns are a frontend concern, but the back-end guarantees that if a foreign key is set, it refers to the correct record and can be used for a deep-link.
	
	\subsection*{Read, dismiss and retention}
	
	\begin{itemize}
		\item \texttt{read}:
		\begin{itemize}
			\item Set to \texttt{True} when the user clicks through or explicitly marks the notification as read.
			\item Used to badge the notification icon and retrieve ``unread only'' lists.
		\end{itemize}
		\item \texttt{dismissed}:
		\begin{itemize}
			\item Set to \texttt{True} when the user hides a notification from the main list.
			\item Read and dismissed are independent; a notification can be read but not dismissed, or vice versa.
		\end{itemize}
		\item Retention:
		\begin{itemize}
			\item Notifications are short-lived by design; they may be purged after a time-based retention period via a cron job rather than via FK cascades.
			\item Currently, foreign keys ensure that when the \texttt{recipient} or the referenced group/task/message is deleted, the notification row is also removed.
			\end{itemize}
		\end{itemize}
		
		\section{Non-goals and Scope}
		
		This section captures features and directions that are explicitly out of scope for the initial ChoreSync implementation.
		
		\begin{itemize}
			\item \textbf{Advanced ML/AI scheduling}:
			the assignment engine is rule- and score-based; there is no plan in this version to use machine learning models for prediction or optimisation.
			
			\item \textbf{Financial tracking and billing}:
			ChoreSync does not handle money, payments, or complex ``fairness'' accounting in currency units (no rent-splitting, no billing integration).
			
			\item \textbf{Offline-first operation}:
			the app assumes connectivity to the back-end and external calendar providers; it does not implement conflict resolution or offline sync for long periods.
			
			\item \textbf{Native mobile clients}:
			for this phase, the UI is a web app / SPA. There are no separate Android/iOS native clients planned.
			
			\item \textbf{Exotic calendar providers}:
			support is limited to an internal calendar plus a small number of external providers (currently Google / Microsoft). There is no generic CalDAV or long tail of providers.
			
			\item \textbf{Complex permission hierarchies}:
			role models are intentionally simple (e.g.\ owner, moderator, member). There is no per-task ACL system or deeply nested group structure.
			
			\item \textbf{Cross-group global fairness}:
			fairness is computed per group; there is no attempt to coordinate fairness across multiple unrelated groups a user might belong to.
		\end{itemize}
		
		\section{Messaging and new members}
		
		\subsection{New members and historical messages}
		
		When a user recently joins a group:
		
		\begin{itemize}
			\item New users should only see messages that were sent after they joined.
			\item Otherwise:
			\begin{itemize}
				\item The system might create message receipts for thousands of historical messages the user will never read.
				\item This can cause unnecessary storage and performance overhead later.
			\end{itemize}
		\end{itemize}
		
		\section{Entity Lifecycle and Delete Policies}
		
		This section summarises, at a high level, what happens when major entities are deleted (see the On-Delete Behaviour section for full foreign-key detail).
		
		\begin{itemize}
			\item \textbf{User}:
			deleting a user removes their group memberships, votes, task preferences, external credentials, calendars (and their events), message receipts, and notifications. References such as
			\texttt{creator}, \texttt{assigned\_to}, \texttt{proposed\_by}, \texttt{from\_user}, \texttt{to\_user} and \texttt{sender} are nulled where configured. Any outstanding tasks they were responsible for are expected to be handled by reassignment services.
			
			\item \textbf{Group}:
			deleting a group deletes all group-scoped data:
			memberships, task templates, task occurrences, proposals, votes, preferences, swaps tied to those occurrences, messages, notifications that reference the group, and the \texttt{GroupCalendar} settings row. Group-level fairness/insight metrics (if added later) should also be scoped to the group and removed at this point.
			
			\item \textbf{GroupMembership}:
			memberships are transient join records. They are deleted automatically when either the user or the group is deleted. Service logic (e.g.\ membership leave flows) is responsible for triggering any reassignment of that memberâ€™s tasks before or after the membership is removed.
			
			\item \textbf{TaskTemplate}:
			deleting a template deletes its occurrences and preferences. Proposals that referenced it remain as historical records but lost the direct taskemplate link This in turn deletes any swaps for those occurrences, and removes or detaches occurrence-linked notifications and calendar events according to their on-delete rules. Templates are long-lived; they are normally removed only by explicit moderator/admin actions or when a group is deleted.
			
			\item \textbf{TaskOccurrence}:
			deleting an occurrence deletes any swaps tied to that occurrence and any notifications that directly reference it, and detaches associated calendar events by nulling the \texttt{task\_occurrence} link (the event itself remains as a normal calendar entry). Occurrences are short- to medium-lived instances which may be completed, swapped, or reassigned before eventually being archived or deleted.
			
			\item \textbf{TaskProposal, TaskVote, TaskPreference}:
			proposals, votes and preferences are tightly tied to both group and template. When a group or template is deleted, all attached proposals, votes and preferences are removed. Over time, proposals move through states (\texttt{pending} $\rightarrow$ \texttt{approved}/\texttt{rejected}/\texttt{expired}); votes are immutable records of decisions for that proposal; preferences persist across multiple occurrences of the same template until the template (or user) is deleted.
			
			\item \textbf{TaskSwap}:
			swaps are tied to a specific \texttt{TaskOccurrence}. When the occurrence is deleted, all swaps for it are deleted. If either party to the swap is deleted, the \texttt{from\_user} / \texttt{to\_user} fields are set to \texttt{null}, preserving the swap record for history and analytics while anonymising the former member. Swaps move through a simple lifecycle (\texttt{pending} $\rightarrow$ \texttt{cancelled}).
			
			\item \textbf{Calendar \& Event}:
			deleting a calendar deletes all in-app events on that calendar. External providers (Google, Microsoft) are \emph{not} modified by cascades; any external purge or disconnect flows must be explicitly implemented in services. Events derived from tasks retain a loose link via \texttt{task\_occurrence}; when that occurrence is 
		\end{itemize}
		\end{document}